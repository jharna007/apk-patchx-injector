name: Patch APK (apk-patchx)

on:
  workflow_dispatch:
    inputs:
      arch:
        description: 'Target arch: arm, arm64, x86, x86_64'
        required: true
        default: 'arm64'
        type: choice
        options: [arm, arm64, x86, x86_64]
      frida_version:
        description: 'Optional Frida version (e.g., 16.2.1). Leave empty for latest.'
        required: false
        type: string
      add_net:
        description: 'Add permissive networkSecurityConfig'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']

jobs:
  patch:
    runs-on: ubuntu-latest
    env:
      APK_URL: https://github.com/kaifcodec/Upload_apk/releases/download/v1.0.4/base_ins_lite.apk
      APK_NAME: base_ins_lite.apk
      OUT_BASE: base_ins_lite.gadget
      SIGNED_APK: base_ins_lite.gadget.signed.apk

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install apk-patchx
        run: |
          python -m pip install --upgrade pip
          pip install apk-patchx
        # Standard pip install for public PyPI package. [2]

      - name: Set up Java (required for apktool/apksigner)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
        # keytool/apksigner need a JRE/JDK; temurin 17 is fine for CI. [6]

      - name: Download APK
        run: |
          set -eux
          curl -L "$APK_URL" -o "$APK_NAME"
          ls -lah "$APK_NAME"
        # Simple curl download pattern for public release assets. [2][3]

      - name: Pre-create tool dirs (avoid root-owned)
        run: |
          set -eux
          mkdir -p "${HOME}/.apkpatcher/tools"
          mkdir -p "${HOME}/.apkpatcher/tools/cmdline-tools"
          mkdir -p "${HOME}/.apkpatcher/tools/sdk"
        # Ensures apk-patchx writes into $HOME and not into restricted paths. [2]

      - name: Fix cmdline-tools permissions
        run: |
          set -eux
          if [ -d "${HOME}/.apkpatcher/tools/cmdline-tools/bin" ]; then
            chmod +x "${HOME}/.apkpatcher/tools/cmdline-tools/bin/"* || true
          fi
          if [ -d "${HOME}/.apkpatcher/tools/sdk/build-tools" ]; then
            find "${HOME}/.apkpatcher/tools/sdk/build-tools" -type f -maxdepth 2 -printf '%p\0' | xargs -0 -r chmod +x || true
          fi
          if [ -d "${HOME}/.apkpatcher/tools/sdk/platform-tools" ]; then
            chmod +x "${HOME}/.apkpatcher/tools/sdk/platform-tools/"* || true
          fi
        # Sets exec bit on sdkmanager/adb/zipalign/apksigner if present already. [2][3]

      - name: Show versions
        run: |
          apk-patchx --version || true
          java -version || true
          python --version || true
        # Sanity check to print tool versions. [2]

      - name: Patch with apk-patchx (with retry)
        run: |
          set -eux
          ARCH="${{ inputs.arch }}"
          FRIDA_VERSION="${{ inputs.frida_version }}"
          NET_FLAG=""
          [ "${{ inputs.add_net }}" = "true" ] && NET_FLAG="--net"

          try_patch() {
            if [ -n "${FRIDA_VERSION}" ]; then
              apk-patchx patch "${APK_NAME}" --arch "${ARCH}" ${NET_FLAG} --frida-version "${FRIDA_VERSION}"
            else
              apk-patchx patch "${APK_NAME}" --arch "${ARCH}" ${NET_FLAG}
            fi
          }

          # First attempt
          if ! try_patch; then
            echo "First attempt failed; repairing permissions and retrying..."
            # Fix permissions again in case the tool just downloaded cmdline-tools
            if [ -d "${HOME}/.apkpatcher/tools/cmdline-tools/bin" ]; then
              chmod +x "${HOME}/.apkpatcher/tools/cmdline-tools/bin/"* || true
            fi
            if [ -d "${HOME}/.apkpatcher/tools/sdk/build-tools" ]; then
              find "${HOME}/.apkpatcher/tools/sdk/build-tools" -type f -maxdepth 2 -printf '%p\0' | xargs -0 -r chmod +x || true
            fi
            if [ -d "${HOME}/.apkpatcher/tools/sdk/platform-tools" ]; then
              chmod +x "${HOME}/.apkpatcher/tools/sdk/platform-tools/"* || true
            fi
            # Retry
            try_patch
          fi

          # Detect output
          OUT=""
          for c in \
            "$(basename "${APK_NAME%.apk}").gadget_signed.apk" \
            "$(basename "${APK_NAME%.apk}").gadget.signed.apk" \
            "$(basename "${APK_NAME%.apk}").gadget.apk" \
            "$(basename "${APK_NAME%.apk}").gadget.aligned.apk" \
            "$(basename "${APK_NAME%.apk}").gadget-unsigned.apk"
          do
            if [ -f "$c" ]; then OUT="$c"; break; fi
          done
          if [ -z "$OUT" ]; then
            OUT="$(ls -1t *.apk | head -n1)"
          fi
          echo "Patched output detected: $OUT"
          test -n "$OUT" && test -f "$OUT"
          cp -f "$OUT" "${OUT_BASE}.apk"
        # Retry pattern plus permission fix avoids “Permission denied” on sdkmanager. [2][3]

      - name: Generate throwaway keystore (runtime)
        run: |
          set -eux
          openssl rand -hex 8 > rand.txt
          RAND="$(cat rand.txt)"
          KEYSTORE="throwaway-${RAND}.keystore"
          ALIAS="alias_${RAND}"
          STOREPASS="$(openssl rand -hex 16)"
          KEYPASS="$(openssl rand -hex 16)"
          echo "KEYSTORE=${KEYSTORE}" >> $GITHUB_ENV
          echo "ALIAS=${ALIAS}" >> $GITHUB_ENV
          echo "STOREPASS=${STOREPASS}" >> $GITHUB_ENV
          echo "KEYPASS=${KEYPASS}" >> $GITHUB_ENV

          keytool -genkey -v \
            -keystore "${KEYSTORE}" \
            -alias "${ALIAS}" \
            -keyalg RSA \
            -keysize 2048 \
            -validity 10000 \
            -storepass "${STOREPASS}" \
            -keypass "${KEYPASS}" \
            -dname "CN=Throwaway, OU=CI, O=CI, L=CI, S=CI, C=US" \
            -noprompt
        # Standard runtime keystore generation via keytool. [6]

      - name: Align and sign with throwaway keystore
        run: |
          set -eux
          if command -v zipalign >/dev/null 2>&1; then
            ZIPALIGN="$(command -v zipalign)"
          else
            ZIPALIGN="${HOME}/.apkpatcher/tools/sdk/build-tools/33.0.1/zipalign"
          fi
          if command -v apksigner >/dev/null 2>&1; then
            APKSIGNER="$(command -v apksigner)"
          else
            APKSIGNER="${HOME}/.apkpatcher/tools/sdk/build-tools/33.0.1/apksigner"
          fi
          test -x "${ZIPALIGN}" || { echo "zipalign not found"; exit 1; }
          test -x "${APKSIGNER}" || { echo "apksigner not found"; exit 1; }

          "${ZIPALIGN}" -p 4 "${OUT_BASE}.apk" "${OUT_BASE}.aligned.apk"

          "${APKSIGNER}" sign \
            --ks "${KEYSTORE}" \
            --ks-key-alias "${ALIAS}" \
            --ks-pass "pass:${STOREPASS}" \
            --key-pass "pass:${KEYPASS}" \
            --out "${SIGNED_APK}" \
            "${OUT_BASE}.aligned.apk"
        # Canonical finalize: align then sign for installable output. [7][8]

      - name: Upload patched APK
        uses: actions/upload-artifact@v4
        with:
          name: apk-patched
          path: ${{ env.SIGNED_APK }}
        # Artifact upload with v4 (recommended). [4][5]
